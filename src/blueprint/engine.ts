import { readFileSync, existsSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { load } from 'js-yaml';
import { buildCapabilityGraph, resolveCapabilities, selectConnectors } from '../capability/graph.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const BLUEPRINTS_DIR = join(__dirname, '../../BLUEPRINTS');

export interface Blueprint {
  id: string;
  version: string;
  title: string;
  description: string;
  goals: string[];
  required_capabilities: string[];
  preferred_connectors: string[];
  policy_pack: string;
  first_run_pipeline?: string;
  manual_steps?: string[];
}

export interface PlanOfRecord {
  blueprint: Blueprint;
  required_capabilities: string[];
  connectors_needed: { connector: string; covers: string[] }[];
  manual_steps: string[];
  markdown: string;
}

const BLUEPRINT_FILES = ['creator.yaml', 'researcher.yaml', 'builder.yaml', 'legal_research.yaml'];

export function loadBlueprints(): Blueprint[] {
  const blueprints: Blueprint[] = [];

  for (const file of BLUEPRINT_FILES) {
    const filePath = join(BLUEPRINTS_DIR, file);
    if (!existsSync(filePath)) continue;
    try {
      const raw = readFileSync(filePath, 'utf8');
      const parsed = load(raw) as Blueprint;
      blueprints.push(parsed);
    } catch {
      // Skip malformed blueprints
    }
  }

  return blueprints;
}

export function selectBlueprint(
  blueprints: Blueprint[],
  goals: string[],
): Blueprint | null {
  if (blueprints.length === 0) return null;

  // Score each blueprint by how many of its goals match user goals
  let bestScore = -1;
  let best: Blueprint | null = null;

  for (const bp of blueprints) {
    let score = 0;
    const bpWords = bp.goals.join(' ').toLowerCase().split(/\W+/).filter(Boolean);
    for (const userGoal of goals) {
      const userWords = userGoal.toLowerCase().split(/\W+/).filter((w) => w.length > 3);
      for (const word of userWords) {
        if (bpWords.includes(word)) score++;
      }
    }
    if (score > bestScore) {
      bestScore = score;
      best = bp;
    }
  }

  return best;
}

export function generatePlanOfRecord(
  blueprint: Blueprint,
  workspaceId: string,
): PlanOfRecord {
  const graph = buildCapabilityGraph();
  const resolvedCaps = resolveCapabilities(graph, blueprint.required_capabilities);
  const connectors = selectConnectors(graph, resolvedCaps);

  const manualSteps: string[] = [];

  // Add connector-specific manual steps
  for (const { connector } of connectors) {
    if (connector === 'connector.github.app') {
      manualSteps.push('Sign in with GitHub via OAuth (cloned connect github)');
      manualSteps.push('Install Cloned GitHub App on your organization/repos');
    }
    if (connector === 'connector.youtube.oauth') {
      manualSteps.push('Authorize YouTube access via OAuth (cloned connect youtube)');
    }
  }

  // Add blueprint-specific manual steps
  if (blueprint.manual_steps) {
    manualSteps.push(...blueprint.manual_steps);
  }

  const markdown = renderPlanMarkdown(blueprint, resolvedCaps, connectors, manualSteps, workspaceId);

  return {
    blueprint,
    required_capabilities: resolvedCaps,
    connectors_needed: connectors,
    manual_steps: manualSteps,
    markdown,
  };
}

function renderPlanMarkdown(
  blueprint: Blueprint,
  capabilities: string[],
  connectors: { connector: string; covers: string[] }[],
  manualSteps: string[],
  workspaceId: string,
): string {
  const now = new Date().toISOString();
  return `# Plan of Record

## Blueprint: ${blueprint.title}
**Version:** ${blueprint.version}
**Workspace:** ${workspaceId}
**Generated:** ${now}

## Description
${blueprint.description}

## Goals
${blueprint.goals.map((g) => `- ${g}`).join('\n')}

## Required Capabilities
${capabilities.map((c) => `- \`${c}\``).join('\n')}

## Connectors to Install
${
  connectors.length > 0
    ? connectors
        .map(
          ({ connector, covers }) =>
            `- **${connector}**\n  Provides: ${covers.join(', ')}`,
        )
        .join('\n')
    : '- No additional connectors required'
}

## Manual Steps Required
${
  manualSteps.length > 0
    ? manualSteps.map((s, i) => `${i + 1}. ${s}`).join('\n')
    : 'None'
}

## Policy Pack
${blueprint.policy_pack}

## First Run Pipeline
${blueprint.first_run_pipeline ?? 'Not configured'}

---
*This plan was generated by Cloned onboarding. Run \`cloned run <pipeline>\` to start.*
`;
}
